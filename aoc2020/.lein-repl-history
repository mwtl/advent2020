d1-solution-part1
d1-solution-part2
(take 1 d2-input)
d2-input
(clojure.string/split-lines (slurp "resources/day2.txt"))
(take 1 d2-input)
(nth 1 (take 1 d2-input))
(nth (take 1 d2-input) 1)
(take 1 d2-input)
(d2/d2-parser (take 1 d2-input))
(require '[clojure.string :as str])
(def x (take 1 d2-input))
(str/split x #" ")
x
(get x 0)
(take 1 x)
(map #(d2/d2-parser %1) d2-input)
(take 1 (map #(d2/d2-parser %1) d2-input))
(take 1 "ab")
(get 1 "ab")
(map #(d2/d2-parser %1) d2-input)
(map #(d2/parser %1) d2-input)
(def x (take 1 (map #(d2/parser %1) d2-input)))
x
(flatten x)
(def y {:min "15", :max "16", :character \m, :value "mhmjmzrmmlmmmmmm"})
y
(valid? y)
(d2/valid? y)
(:character y)
(re-seq (:character input) (:value input))
(re-seq (re-pattern (:character input)) (:value input))
(re-seq (re-pattern (:character y)) (:value y))
(:value y)
(re-seq #"\m" (:value y))
(re-seq #"m" (:value y))
(re-pattern (:character value))
(re-pattern (:character y))
(re-pattern (:character "x"))
(re-pattern (:character "\x"))
(re-pattern (:character "\\x"))
(re-pattern "\x"))
(re-pattern "\x")
(re-pattern "\\x")
(re-pattern '"\\x")
(re-pattern '"x")
(re-pattern '"\x")
(:character y)
(str (:character y))
(re-pattern (str (:character y)))
(def y {:min "15", :max "16", :character \m, :value "mhmjmzrmmlmmmmmm"})
(valid? y)
(d2/valid? y)
(<= 11 15
)
(>= 11 5)
(>= 11 15)
(map #(d2/solution %1) d2-input)
(map #(occurences (count (re-seq (re-pattern (str (:character input))) (:value input))) %1) d2-input)
(map #(occurences (count (re-seq (re-pattern (str (:character %1))) (:value %1)))) d2-input)
(map #(d2/parser %1) d2-input)
(map #(d2/valid? %1) d2-input)
(map #(d2/solution %1) d2-input)
(def x (map #(d2/solution %1) d2-input))
x
(filter #(= true (:valid %)) x)
(count (filter #(= true (:valid %)) x))
(map #(d2/solution %1) d2-input)
(d2/solution d2-input)
d2-solution-part1
(count true `(true false))
(+ true true)
(get "abc" 1)
(d2/parser d2-input)
(map #(d2/parser %1) d2-input)
(map #(d2/part2-valid? %1) d2-input)
(filter identy (true false))
(filter (= true %1) '(true false false true))
(filter (= true '(true false false true))
)
(filter #(= true %1) '(true false false true))
(map #(d2/part2-valid? %1) d2-input)
(map #(d2/parser? %1) d2-input)
(map #(d2/parser %1) d2-input)
(d2/part2-valid? {:min 9, :max 16, :character \d, :value "dsdddddddrdddddhdbdd"})
(map #(d2/result-map %1) d2-input)
(def d2-solution-part2 (d2/p2-solution d2-test-input))
d2-solution-part2
(d2/p2-solution d2-test-input)
(d2/p2-solution d2-input)
(d2/p2-solution d2-test-input)
(d2/p2-solution d2-input)
(- 1 200)
(- 2 1)
(d2/p2-solution d2-input)
cd ..
