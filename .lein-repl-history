(d4/p2-solution d4/input)
input-test
x
(take 5 x)
(take 7 x)
(take 8 x)
(nth (take 7 x) 0)
(= (nth (take 7 x) 0) "F")
(= (nth (take 7 x) 0) \F)
(127 / 2)
(/ 127 2)
(math/floor (/ 127 2))
(Math/floor (/ 127 2))
(int (Math/floor (/ 127 2)))
(int (Math/ceil (/ 127 2)))
(int (Math/floor (/ 127 2)))
(+ 0 63)
(- 127 63)
(clojure.string/split x "#\d+" 1)
(clojure.string/split x "#\d" 1)
(clojure.string/split x "#/d+" 1)
(clojure.string/split x #\d+" 1)
(clojure.string/split x #"\d+" 1)
x
(clojure.string/split x #"\d+" 2)
(clojure.string/split x #"" 1)
(clojure.string/split x #"" 2)
(take 1 x)
(nth (clojure.string/split x #"" 2) 1)
(nth (clojure.string/split x #"" 2) 0)
(nth (clojure.string/split x #"" 2) 3)
(def y "y")
(clojure.string/split y #"" 2)
(clojure.string/split "" #"" 2)
(nth (clojure.string/split x #"" 2) 0)
(nth (clojure.string/split x #"" 2) 1)
(take 1 x)
(nth (take 1 x) 0)
(lenght x)
(count x)
(subs x 1)
(/ (- 127 0) 2)
(int (Math.ceil (/ (- 127 0) 2)))
(int (Math/ceil (/ (- 127 0) 2)))
(int (Math/floor (/ (- 127 0) 2)))
(int (Math/floor (/ (- 63 0) 2)))
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 x) 0)
                (/B /R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
(case (nth (take 1 x) 0)
                (/B /R) true
(case (nth (take 1 x) 0)
                ("/B" "/R") true
                false)
(take 1 x)
(case (nth (take 1 x) 0)
                ("/B" "/F") true
                false)
(case (nth (take 1 x) 0)
                '(/B /F) true
(case (nth (take 1 x) 0)
                (\B \F) true
                false)
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 x) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper (reducer next-lower next-upper next))))
(reducer 0 127 "FBFBBFF")
(reducer 0 127 "FBFBBFF")(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 x) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper next-lower)))
(reducer 0 127 "FBFBBFF")
(def l 0)
l
(def u 127)
(def value (defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 x) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        next-upper (if (true? up?) upper (+ lower next-n))])))))))
(def value "FBFBBFF")
(def next (subs value 1))
(def next2 (subs value 1))
next
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper next-lower)))
(reducer 0 127 "FBFBBFF")
value
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper next-lower)))
(def up? (case (nth (take 1 value) 0)
                (\B \R) true
                false))
up?
(def next-n (int (Math/floor (/ (- u l) 2)))
)
next-n
(def next-lower (if (true? up?) (- upper next-n) l))
(def next-lower (if (true? up?) (- u next-n) l))
next-lower
u
next-n
l
(def next-upper (if (true? up?) u (+ l next-n)))
next-upper
next-lower
(= next-upper next-lower)
(next-upper)
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper next-lower)))
(reducer 0 127 x)
next
next2
up?
next-n
next-lower
next-upper
next
(reducer 0 127 x)
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        [:up next-upper :low next-lower]))
(reducer 0 127 x)
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper next-upper)))
(reducer 0 127 x)
(defn reducer [lower upper value]
  (let [next (subs value 1)
        up? (case (nth (take 1 value) 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper (reducer next-lower next-upper next))))
(reducer 0 127 x)
(clojure.string/split x 7)
(clojure.string/split x "" 7)
(clojure.string/split x #"" 7)
(clojure.string/split x #"" 8)
(split-at 7 x)
(nth (split-at 7 x) 0)
(str (nth (split-at 7 x) 0))
(subs (nth (split-at 7 x) 0) 1)
(take 1 (nth (split-at 7 x) 0))
(nth (split-at 7 x) 0)
(rest (nth (split-at 7 x) 0))
(nth (nth (split-at 7 x) 0) 0)
(def x ())
(nth x 0)
(rest x)
(defn reducer [lower upper value]
  (let [next (rest value)
        up? (case (nth value 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper (reducer next-lower next-upper next))))
(defn parse-pass [boardingpass]
  (let [row (reducer 0 127 (nth (split-at 7 boardingpass) 0))
        column (reducer 0 7 (nth (split-at 7 boardingpass) 1))]
        [:row row :column column :seat-id (+ (* row 8) column]))
(defn reducer [lower upper value]
  (let [next (rest value)
        up? (case (nth value 0)
                (\B \R) true
                false)
        next-n (int (Math/floor (/ (- upper lower) 2)))
        next-lower (if (true? up?) (- upper next-n) lower)
        next-upper (if (true? up?) upper (+ lower next-n))]
        (if (= next-upper next-lower) next-upper (reducer next-lower next-upper next))))
(defn parse-pass [boardingpass]
  (let [row (reducer 0 127 (nth (split-at 7 boardingpass) 0))
        column (reducer 0 7 (nth (split-at 7 boardingpass) 1))]
        [:row row :column column :seat-id (+ (* row 8) column)]))
(def x "FBFBBFFRLR")
(parse-pass x)
(max (1 4 5))
(d5/p1-solution d5/input)
(map #(parse-pass %) d5/input)
(map #(parse-pass %) d5/input-test)
(map #(d5/parse-pass %) d5/input)
(def y (take 1 (map #(d5/parse-pass %) d5/input)))
y
(nth y 0)
(:sead-id (nth y 0))
(:seat-id (nth y 0))
((nth y 0) :seat-id)
(get :seat-id (nth y 0))
(def foo {:foo bar})
(def foo {:foo "bar"})
(:foo foo)
(d5/p1-solution d5/input)
(filter #(:seat-id %) (map #(d5/parse-pass %) d5/input))
(def foo {:foo "bar"})
(get foo :foo)
(map #(get % :seat-id) (map #(d5/parse-pass %) d5/input))
(apply max (map #(get % :seat-id) (map #(d5/parse-pass %) d5/input)))
(map #(d5/parse-pass %) d5/input))
(map #(d5/parse-pass %) d5/input)
(def pass (map #(d5/parse-pass %) d5/input))
pass
(take 1 pass)
(def foo (nth (take 1 pass) 0))
foo
(foo :column)
(filter #(and (= (% :column) 2) (= (% :row 2))) (nth pass 0))
(filter #(and (= (% :column) 2) (= (% :row) 2)) (nth pass 0))
(and (= (foo :column) 2) (= (foo :row) 2))
(filter #(and (= (foo :column) 2) (= (foo :row) 2)) pass)
(filter #(and (= (foo :column) 2) (= (foo :row) 2)) (nth pass 0))
(filter #(and (= (% :column) 2) (= (% :row) 2)) pass)
(filter #(and (= (% :column) 2) (= (% :row) 1)) pass)
(filter #(and (= (% :column) 2) (= (% :row) 1)) (nth pass 0))
pass
(apply hash-map pass)
(take 2 pass)
(nth pass 0)
(filter #(and (= (% :column) 2) (= (% :row) 1)) pass)
foo
(foo :column)
(= (foo :column) 2)
(filter #(and (= (% :column) 2) (= (% :row) 2)) pass)
(filter #(= (% :column) 2) pass)
(filter #(and (= (% :column) 2) (= (% :row) 15)) pass)
(true? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass))
(nil?? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass))
(nil? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass))
(nil? (filter #(and (= (% :column) 2) (= (% :row) 2)) pass))
(contains? {} (filter #(and (= (% :column) 2) (= (% :row) 2)) pass))
(contains? {} (filter #(and (= (% :column) 2) (= (% :row) 15)) pass))
(contains? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass){})
(contains? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass)map)
(empty? (filter #(and (= (% :column) 2) (= (% :row) 15)) pass))
(empty? (filter #(and (= (% :column) 2) (= (% :row) 2)) pass))
(defn seat-id [row coll]
  (+ (* row 8) coll))
(defn exists? [row coll data]
  (let [pass-exists? (empty? (filter #(and (= (% :column) coll) (= (% :row) row)) data))]
  (if pass-exists? nil (hash-map :column coll :row row :seat-id (seat-id row coll)))))
pass
(exists? 2 2 pass)
(exists? 2 1 pass)
(exists? 1 1 pass)
(empty? (filter #(and (= (% :column) 1) (= (% :row) 1)) pass))
(def bar (empty? (filter #(and (= (% :column) 1) (= (% :row) 1)) pass)))
(seat-id 1 1)
bar
(if bar nil (hash-map :column 1 :row 1 :seat-id (seat-id 1 1)))
(not true)
(not false)
(defn exists? [row coll data]
  (let [pass-exists? (not (empty? (filter #(and (= (% :column) coll) (= (% :row) row)) data)))]
  (if pass-exists? nil (hash-map :column coll :row row :seat-id (seat-id row coll)))))
(exists 1 1 pass)
(exists? 1 1 pass)
(exists? 15 15 pass)
(exists? 15 2 pass)
(map #(hash-map :row %1 :col %2) (take 4 (range)) (take 2 (range)))
(defn check-rows [coll data]
  (map #(exists? % coll data) (take 128 (range))))
(check-rows 1 pass)
(count pass)
(8 * 127)
(* 8 127)
(- (* 8 127) 16)
(- (* 7 127) 16)
(- (* 8 128) 16)
(- (* 8 128) 873)
(/ 152 8)
(check-rows 0 pass)
(check-rows 7 pass)
(check-rows 8 pass)
(count (check-rows 8 pass))
(count (check-rows 7 pass))
(count (check-rows 6 pass))
(check-rows 7 pass)
(reduce (check-rows 7 pass))
(remove nil? (check-rows 7 pass))
(count (remove nil? (check-rows 7 pass)))
(count (remove nil? (check-rows 0 pass)))
(count (remove nil? (check-rows 1 pass)))
(count (remove nil? (check-rows 2 pass)))
(count (remove nil? (check-rows 3 pass)))
(count (remove nil? (check-rows 4 pass)))
(count (remove nil? (check-rows 5 pass)))
(count (remove nil? (check-rows 6 pass)))
(count (remove nil? (check-rows 7 pass)))
(min-key :row pass)
(count (remove nil? (check-rows 7 pass)))
(remove nil? (check-rows 7 pass))
pass
d4/passes
(d4/input)
d5/passes
(d5/check-pass d6/passes)
(d5/check-pass d5/passes)
(flatten (d5/check-pass d5/passes))
(get-in (flatten (d5/check-pass d5/passes)) {:row 1})
(get-in (flatten (d5/check-pass d5/passes)) :row)
(get-in (flatten (d5/check-pass d5/passes)) {:row})
(get-in (flatten (d5/check-pass d5/passes)) [:row])
(filter #(= :row 1) (flatten (d5/check-pass d5/passes)))
(filter #(= (:row %) 1) (flatten (d5/check-pass d5/passes)))
(count (filter #(= (:row %) 1) (flatten (d5/check-pass d5/passes))))
(if (= 8 (count (filter #(= (:row %) 1) (flatten (d5/check-pass d5/passes))))) true false)
(d5/non-rows)
(def data (flatten (d5/check-pass d5/passes)))
data
d5/rows
(d5/non-row data 0)
(def data (flatten (d5/check-pass d5/passes)))
(d5/non-row data 0)
(d5/non-row data 5)
(d5/non-row data 9)
(d5/non-row data 15)
(d5/non-row data 10)
(d5/non-row data 11)
(d5/non-row data 12)
(d5/non-row data 122)
(d5/non-row data 121)
(d5/non-row data 120)
(d5/non-row data 119)
(d5/non-row data 118)
(d5/non-row data 117)
(d5/non-row data 116)
(d5/non-rows)
(d5/check-pass d5/passes)
(flatten (d5/check-pass d5/passes))
(count (flatten (d5/check-pass d5/passes)))
(d5/non-row (flatten (d5/check-pass d5/passes)) 1)
(d5/non-row (flatten (d5/check-pass d5/passes)) 2)
(d5/non-row (flatten (d5/check-pass d5/passes)) 16)
(d5/non-row (flatten (d5/check-pass d5/passes)) 13)
d5/rows
(d5/non-row (flatten (d5/check-pass d5/passes)) 127)
(d5/non-row (flatten (d5/check-pass d5/passes)) 0)
d5/non-rows
d5/p2-solution
(flatten (d5/check-pass d5/passes))
(def x (flatten (d5/check-pass d5/passes)))
x
(filter #(= (:column %) 116) x)
(filter #(= (:column %) 7) x)
(filter #(= (:row %) 116) x)
(d5/seat-id 0 116)
(d5/seat-id 1 116)
(d5/seat-id 116 0)
(def x (flatten (d5/check-pass d5/passes)))
(filter #(= (:row %) 116) x)
d5/p2-solution
(d5/exists 166 0 passes)
(d5/exists? 166 0 passes)
(d5/exists? 166 0 d5/passes)
(d5/exists? 166 1 d5/passes)
(d5/exists? 166 2 d5/passes)
(d5/exists? 116 2 d5/passes)
(d5/exists? 116 0 d5/passes)
(d5/exists? 116 1 d5/passes)
(d5/exists? 115 0 d5/passes)
(d5/exists? 115 1 d5/passes)
(d5/exists? 115 7 d5/passes)
(d5/exists? 115 6 d5/passes)
data
(def data (flatten (d5/check-pass d5/passes)))
data
d5/passes
(count (d5/passes))
(count d5/passes)
(count data)
(+ 837 137)
d5/colls
(combo/combinations d5/colls d5/rows)
(for [x d5/rows, y d5/colls (list x y))
(for [x d5/rows, y d5/colls] (list x y))
(count (for [x d5/rows, y d5/colls] (list x y)))
(* 128 8)
d5/all-seats
(count d5/all-seats)
d5/all-seats
(nth d5/all-seats 0)
(:column (nth d5/all-seats 0))
(remove #(nil? (exists? (:row %) (:column %) d5/input)) d5/all-seats)
(remove #(nil? (d5/exists? (:row %) (:column %) d5/input)) d5/all-seats)
(nth d5/all-seats 0)
(remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats)
(count (remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats))
d5/passes
(count (remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats))
(count d5/passes
)
(+ 187 837)
(filter #(and (= (% :column) 0) (= (% :row) 0)) d5/passes)
d5/empty-seats
(count d5/empty-seats)
(count d5/passes)
d5/empty-seats
(if (= 1 1) true )
(if (= 1 2) true )
(or (= 1 1) (or 1 2))
d5/rows
(min d5/rows)
(apply min d5/rows)
d5/all-seats
(count d5/all-seats)
(count d5/passes)
(count d5/empty-seats)
(+ 837 171)
d5/empty-seats
(def empty-seat-ids (map #(:seat-id %) d5/empty-seats)
)
empty-seat-ids
(remove #(= % (next %)) empty-seat-ids)
empty-seat-ids
(next empty-seat-ids)
(second empty-seat-ids)
(remove #(= % (second %)) empty-seat-ids)
(remove #(= %1 %2) empty-seat-ids (second empty-seat-ids))
(map #(if (= (+ %1 1) %2) nil %1) empty-seat-ids (second empty-seat-ids))
(map #(if (= (+ %1 1) %2) nil %1) empty-seat-ids (next empty-seat-ids))
empty-seat-ids
(take-last empty-seat-ids)
(take-last 1 empty-seat-ids)
(first empty-seat-ids)
(conj empty-seat-ids (- (first empty-seat-ids) 1))
(pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(conj empty-seat-ids (- (first empty-seat-ids) 1))
(apply pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(butlast (conj empty-seat-ids (- (first empty-seat-ids) 1)))
empty-seat-ids
(last empty-seat-ids)
d5/p2-solutions
(remove nil? d5/p2-solutions)
(reduce nil? d5/p2-solutions)
d5/p2-solutions
d5-solution-part2
d6/input-test
d6/input
(nth d6/input 0)
(def x "aabbcc")
(distinct x)
(map #(count (distinct %)) d6/input)
(reduce + (map #(count (distinct %)) d6/input))
