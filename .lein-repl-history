(slurp "resources/day4-test.txt")
(slurp "resources/day4-test.xt")
(clojure.string/split (slurp "resources/day4-test.xt") #"\n\n")
(def x (clojure.string/split (slurp "resources/day4-test.xt") #"\n\n"))
x
(nth x 0)
(map #(clojure.string/replace % #"/n" " ") x)
(aoc2020.day4/input-test)
aoc2020.day4/input-test
d4/input-test
(d4/create-map d4/input-test)
(d4/input-test)
d4/input-test
(def a "ecl:gry pid:860033327 eyr:2020 hcl:#fffffd byr:1937 iyr:2017 cid:147 hgt:183cm")
(def b "ecl:gry")
(d4/create-kv b)
(def a "ecl:gry pid:860033327 eyr:2020 hcl:#fffffd byr:1937 iyr:2017 cid:147 hgt:183cm")
(d4/create-kv b)
(def b "ecl:gry")
(d4/create-kv b)
(d4/create-map a)
(def c {:ecl "gry"} {:pid "860033327"} {:eyr "2020"} {:hcl "#fffffd"} {:byr "1937"} {:iyr "2017"} {:cid "147"} {:hgt "183cm"})
(reduce conj #{} (d4/create-map a))
(int {} (d4/create-map a))
(into {} (d4/create-map a))
(into {} (d4/create-map input-test))
(into {} (d4/create-map d4/input-test))
(defn create-map [input]
  (let [items (map #(create-kv %) (str/split input #" "))]
  (map #(into {} %) items)))
(defn create-map [input]
  (let [items (map #(d4/create-kv %) (str/split input #" "))]
  (map #(into {} %) items)))
(defn create-map [input]
  (let [items (map #(d4/create-kv %) (clojure.string/split input #" "))]
  (map #(into {} %) items)))
(create-map d4/input-test)
(d4/create-map d4/input-test)
(def items (map #(d4/create-kv %) (clojure.string/split d4/input-test #" ")))
(clojure.string/split d4/input-test #" ")
d4/input-test
(nth d4/input-test 0)
(d4/create-map d4/input-test)
(d4/passports d4/input-test)
(keys {:ecl "gry", :pid "860033327", :eyr "2020", :hcl "#fffffd", :byr "1937", :iyr "2017", :cid "147", :hgt "183cm"})
(every? #(contains? (nth (d4/passports d4/input-test) 0) %) d4/required-fields)
(every? #(contains? (nth (d4/passports d4/input-test) 1) %) d4/required-fields)
(d4/p1-solution d4/input-test)
(d4/passports d4/input-test)
(map #(d4/passport-validator %) (d4/passports d4/input-test))
(nth (d4/passports d4/input-test) 0)
(d4/passports d4/input-test)
(d4/p1-solution d4/input-test)
(d4/passport-validator (nth (d4/passports d4/input-test) 0))
(d4/passport-validator (nth (d4/passports d4/input-test) 1))
(d4/passport-validator (nth (d4/passports d4/input-test) 2))
(d4/passport-validator (nth (d4/passports d4/input-test) 3))
(d4/passport-validator (nth (d4/passports d4/input-test) 4))
(map #(d4/passport-validator %) (d4passports d4/input-test))
(map #(d4/passport-validator %) (d4/passports d4/input-test))
(def (map #(d4/passport-validator %) (d4passports d4/input-test)))
(def x (map #(d4/passport-validator %) (d4passports d4/input-test)))
(def x (map #(d4/passport-validator %) (d4/passports d4/input-test)))
x
(count x)
(filter true? x)
(d4/p1-solution d4/input-test)
(d4/p1-solution d4/input)
(d4/validate {:byr 2002, :iyr 2020, :eyr 2021, :ecl "blu" :hcl "#123abc" :pid "000000002" :hgt {:unit "cm" :value 160}})
(d4/validate? {:byr 2002, :iyr 2020, :eyr 2021, :ecl "blu" :hcl "#123abc" :pid "000000002" :hgt {:unit "cm" :value 160}})
(d4/valid? {:byr 2002, :iyr 2020, :eyr 2021, :ecl "blu" :hcl "#123abc" :pid "000000002" :hgt {:unit "cm" :value 160}})
(re-matches #"^\d{2,3}(cm|inch)$" "120cm")
(re-pattern #"^\d{2,3}(cm|inch)$" "120cm")
(re-matcher #"^\d{2,3}(cm|inch)$" "120cm")
(re-find #"^\d{2,3}(cm|inch)$" "120cm")
(re-group #"^\d{2,3}(cm|inch)$" "120cm")
(re-groups #"^\d{2,3}(cm|inch)$" "120cm")
(re-matcher #"^\d{2,3}(cm|inch)$" "120cm")
(re-find #"^\d{2,3}(cm|inch)$" "120cm")
(re-find #"^\d{2,3}(cm|inch)$" "120 cm")
(re-find #"^\d{2,3}(cm|inch)$" "120cm a")
(def x nil)
(nth x 1)
(re-find #"^\d{2,3}(cm|inch)$" "120cm a")
(re-find #"^\d{2,3}(cm|inch)$" "120cm")
(nth (re-find #"^\d{2,3}(cm|inch)$" "120cm") 1)
(clojure.string/replace "120cm" #"(cm|inch)" "")
(clojure.string/replace "120inc" #"(cm|inch)" "")
(clojure.string/replace "120inch" #"(cm|inch)" "")
(read-string (clojure.string/replace "120inch" #"(cm|inch)" ""))
(hash-map :unit "cm" :value 120)
(k :hgt)
(def k :hgt)
(key k)
(key? k)
k
(= k :hgt)
(= k "hgt")
(d4/passports d4/input-test)
(read-string nil)
(read-string "49in")
(d4/passports d4/input-test)
(d4/transform-hgt "120cm")
(def unit (nth (re-find #"^\d{2,3}(cm|inch)$" "120cm") 1))
unit
(d4/transform-hgt "120cm")
(d4/transform-hgt "120cma")
(def x find-uv (re-find #"^\d{2,3}(cm|inch)$" "120cma"))
(deffind-uv (re-find #"^\d{2,3}(cm|inch)$" "120cma"))
(def find-uv (re-find #"^\d{2,3}(cm|inch)$" "120cma"))
find-uv
(false? find-uv)
(true? find-uv)
(def find-uv (re-find #"^\d{2,3}(cm|inch)$" "120cm"))
(true? find-uv)
(false? find-uv)
find-uv
(def find-uv (re-find #"^\d{2,3}(cm|inch)$" "120aacm"))
find-uv
(nil? find-uv)
(d4/transform-hgt "120cma")
(d4/transform-hgt "120cm")
(d4/transform-hgt "120inch")
(d4/passports d4/input-test)
(d4/passports d4/input)
(d4/p1-solution d4/input)
(d4/p2-solution d4/input)
(d4/passports d4/input)
(nth (d4/passports d4/input) 0)
(d4/p2-valid? (nth (d4/passports d4/input) 0))
(d4/p2-valid? (nth (d4/passports d4/input) 1))
(d4/p2-valid? (nth (d4/passports d4/input-test) 1))
(d4/p2-valid? (nth (d4/passports d4/input-test) 2))
(d4/p2-valid? (nth (d4/passports d4/input-test) 3))
(nth (d4/passports d4/input-test) 0)
(d4/p2-solution d4/input-test)
(nth (d4/passports d4/input-test) 7)
(:require '[malli.core :as m])
(m/validator {:iyr "2010", :hgt {:unit "cm", :value 158}, :hcl "#b6652a", :ecl "blu", :byr "1944", :eyr "2021", :pid "093154719"})
(:require [malli.core :as m])
(m/validator {:iyr "2010", :hgt {:unit "cm", :value 158}, :hcl "#b6652a", :ecl "blu", :byr "1944", :eyr "2021", :pid "093154719"})
(re-matches #"\d" "abc")
(re-matches #"\d" "123")
(re-matches #"/d" "123")
(re-find #"^\d+" "123")
(re-find #"^\d+" "123ab")
(re-matches #"^\d+" "123ab")
(re-matches #"^\d+" "123")
(re-matches #"^\d+" "ab123")
(re-matches #"^\d+" "a123a")
(true? (re-matches #"^\d+" "123"))
(every? #(Character/isDigit %) "123")
(read-string "123")
(read-string "123ab")
(def x :iyr)
(case x (:byr :iyr :eyr) "ja" "other")
(nth (d4/passports d4/input-test) 7)
(d4/p2-solution d4/input-test)
(d4/p2-valid? (nth (d4/passports d4/input-test) 0))
(d4/p2-valid? (nth (d4/passports d4/input-test) 1))
(d4/p2-valid? (nth (d4/passports d4/input-test) 0))
(d4/p2-solution d4/input)
(d4/p2-solution d4/input-test)
(d4/p2-valid? (nth (d4/passports d4/input-test) 0))
(d4/p2-valid? (nth (d4/passports d4/input-test) 1))
(d4/p2-valid? (nth (d4/passports d4/input-test) 2))
(d4/p2-valid? (nth (d4/passports d4/input-test) 3))
(d4/p2-valid? (nth (d4/passports d4/input-test) 4))
(d4/p2-solution d4/input-test)
(d4/p2-solution d4/input)
