(d5/non-row data 15)
(d5/non-row data 10)
(d5/non-row data 11)
(d5/non-row data 12)
(d5/non-row data 122)
(d5/non-row data 121)
(d5/non-row data 120)
(d5/non-row data 119)
(d5/non-row data 118)
(d5/non-row data 117)
(d5/non-row data 116)
(d5/non-rows)
(d5/check-pass d5/passes)
(flatten (d5/check-pass d5/passes))
(count (flatten (d5/check-pass d5/passes)))
(d5/non-row (flatten (d5/check-pass d5/passes)) 1)
(d5/non-row (flatten (d5/check-pass d5/passes)) 2)
(d5/non-row (flatten (d5/check-pass d5/passes)) 16)
(d5/non-row (flatten (d5/check-pass d5/passes)) 13)
d5/rows
(d5/non-row (flatten (d5/check-pass d5/passes)) 127)
(d5/non-row (flatten (d5/check-pass d5/passes)) 0)
d5/non-rows
d5/p2-solution
(flatten (d5/check-pass d5/passes))
(def x (flatten (d5/check-pass d5/passes)))
x
(filter #(= (:column %) 116) x)
(filter #(= (:column %) 7) x)
(filter #(= (:row %) 116) x)
(d5/seat-id 0 116)
(d5/seat-id 1 116)
(d5/seat-id 116 0)
(def x (flatten (d5/check-pass d5/passes)))
(filter #(= (:row %) 116) x)
d5/p2-solution
(d5/exists 166 0 passes)
(d5/exists? 166 0 passes)
(d5/exists? 166 0 d5/passes)
(d5/exists? 166 1 d5/passes)
(d5/exists? 166 2 d5/passes)
(d5/exists? 116 2 d5/passes)
(d5/exists? 116 0 d5/passes)
(d5/exists? 116 1 d5/passes)
(d5/exists? 115 0 d5/passes)
(d5/exists? 115 1 d5/passes)
(d5/exists? 115 7 d5/passes)
(d5/exists? 115 6 d5/passes)
data
(def data (flatten (d5/check-pass d5/passes)))
data
d5/passes
(count (d5/passes))
(count d5/passes)
(count data)
(+ 837 137)
d5/colls
(combo/combinations d5/colls d5/rows)
(for [x d5/rows, y d5/colls (list x y))
(for [x d5/rows, y d5/colls] (list x y))
(count (for [x d5/rows, y d5/colls] (list x y)))
(* 128 8)
d5/all-seats
(count d5/all-seats)
d5/all-seats
(nth d5/all-seats 0)
(:column (nth d5/all-seats 0))
(remove #(nil? (exists? (:row %) (:column %) d5/input)) d5/all-seats)
(remove #(nil? (d5/exists? (:row %) (:column %) d5/input)) d5/all-seats)
(nth d5/all-seats 0)
(remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats)
(count (remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats))
d5/passes
(count (remove #(nil? (d5/exists? (:row %) (:column %) d5/passes)) d5/all-seats))
(count d5/passes
)
(+ 187 837)
(filter #(and (= (% :column) 0) (= (% :row) 0)) d5/passes)
d5/empty-seats
(count d5/empty-seats)
(count d5/passes)
d5/empty-seats
(if (= 1 1) true )
(if (= 1 2) true )
(or (= 1 1) (or 1 2))
d5/rows
(min d5/rows)
(apply min d5/rows)
d5/all-seats
(count d5/all-seats)
(count d5/passes)
(count d5/empty-seats)
(+ 837 171)
d5/empty-seats
(def empty-seat-ids (map #(:seat-id %) d5/empty-seats)
)
empty-seat-ids
(remove #(= % (next %)) empty-seat-ids)
empty-seat-ids
(next empty-seat-ids)
(second empty-seat-ids)
(remove #(= % (second %)) empty-seat-ids)
(remove #(= %1 %2) empty-seat-ids (second empty-seat-ids))
(map #(if (= (+ %1 1) %2) nil %1) empty-seat-ids (second empty-seat-ids))
(map #(if (= (+ %1 1) %2) nil %1) empty-seat-ids (next empty-seat-ids))
empty-seat-ids
(take-last empty-seat-ids)
(take-last 1 empty-seat-ids)
(first empty-seat-ids)
(conj empty-seat-ids (- (first empty-seat-ids) 1))
(pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(conj empty-seat-ids (- (first empty-seat-ids) 1))
(apply pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(pop (conj empty-seat-ids (- (first empty-seat-ids) 1)))
(butlast (conj empty-seat-ids (- (first empty-seat-ids) 1)))
empty-seat-ids
(last empty-seat-ids)
d5/p2-solutions
(remove nil? d5/p2-solutions)
(reduce nil? d5/p2-solutions)
d5/p2-solutions
d5-solution-part2
d6/input-test
d6/input
(nth d6/input 0)
(def x "aabbcc")
(distinct x)
(map #(count (distinct %)) d6/input)
(reduce + (map #(count (distinct %)) d6/input))
d6-solution-part1
d6/p1-solution
d6/questions
d6/p1-solution
d6/questions
d6/p1-solution
d6/questions
(nth input-test 0)
(nth d6/input-test 0)
(str/split (nth d6/input-test 0) #"")
(clojure.string/split (nth d6/input-test 0) #"")
(clojure.string/split-lines (nth d6/input-test 1))
(clojure.string/split-lines (nth d6/input-test 0))
d6/question-groups
(combo/cartesian-product ["ab" "ac"])
(combo/cartesian-product ["a" "b" "c"])
(combo/cartesian-product ["a" "b"] ["a" "c"])
d6/question-groups
(defn counts (def xx (map #(str/split % #"") question-groups)
)
(def x (map #(str/split % #"") question-groups))
(def x (map #(clojure.string/split % #"") question-groups))
(def x (map #(clojure.string/split % #"") d6/question-groups))
x
d6/question-groups
(d6/question-splits (nth d6/question-groups 2))
(d6/question-splits d6/question-groups 2)
(d6/question-splits d6/question-groups)
(nth (d6/question-splits d6/question-groups) 0)
(nth (d6/question-splits d6/question-groups) 1)
(nth (d6/question-splits d6/question-groups) 2)
(combo/cartesian-product (nth (d6/question-splits d6/question-groups) 2))
(combo/cartesian-product (nth (nth (d6/question-splits d6/question-groups) 2) 0))
(nth (d6/question-splits d6/question-groups) 2)
(flatten (nth (d6/question-splits d6/question-groups) 2))
(d6/question-groups)
d6/question-groups
(nth d6/question-groups 2)
(take 1 (nth d6/question-groups 2))
(next (nth d6/question-groups 2))
(flatten (next (nth d6/question-groups 2)))
(clojure.string/split (take 1 (nth d6/question-groups 2)) #"")
(take 1 (nth (d6/question-splits question-groups) 2))
(take 1 (nth (d6/question-splits d6/question-groups) 2))
(flatten (take 1 (nth (d6/question-splits d6/question-groups) 2)))
(d6/question-splits d6/question-groups) 2)
(d6/question-splits d6/question-groups)
(nth (d6/question-splits d6/question-groups) 2)
(nth (d6/question-splits d6/question-groups) 1)
(next (nth (d6/question-splits d6/question-groups) 1))
(next (nth (d6/question-splits d6/question-groups) 2))
(next (nth (d6/question-splits d6/question-groups) 0))
(def foo ["a" "b"])
(def bar ["a" "c"])
(clojure.set/intersection foo bar)
(set foo)
(clojure.set/intersection (set foo) (set bar))
(count (clojure.set/intersection (set foo) (set bar)))
(next (nth (d6/question-splits d6/question-groups) 0))
(nth (d6/question-splits d6/question-groups) 1)
(nth (d6/question-splits d6/question-groups) 0)
(take 1 (nth (d6/question-splits d6/question-groups) 0))
(set (take 1 (nth (d6/question-splits d6/question-groups) 0)))
(def abc ["a" "b" "c"])
(clojure.set/intersection (set foo) (set bar) (set abc))
(intersection ["a"] ["a" "b"])
(clojure.set/intersection ["a"] ["a" "b"])
(clojure.set/intersection (set ["a"]) (set ["a" "b"]))
(d6/count-anwsers '(["a" "b" "c"] ["a"] ["a" "c"]))
(d6/count-anwsers '(["a" "b" "c"] ["a" "c"] ["a" "c"]))
d6/p2-solution
(d6/question-splits d6/question-groups)
(count (d6/question-splits d6/question-groups))
(count (d6/q-splits d6/question-groups))
(count (d6/q-split d6/question-groups))
(d6/q-split d6/question-groups)
(count (d6/q-split d6/question-groups))
(d6/p2-solution d6/input)
(d6/p2-solution d6/input-test)
(drop-last "abc."
)
(str (drop-last "abc.")
)
(apply str (drop-last "abc."))
(contains? "abc" "fooabcbar")
(re-find #"abc" "fooabcbar")
(re-find #"abc" "fooabbar")
(nil? (re-find #"abc" "fooabbar"))
(true? (re-find #"abc" "fooabbar"))
(true? (re-find #"abc" "fooabcbar"))
(nil? (re-find #"abc" "fooabcbar"))
d7/input-test
"light red bags contain 1 bright white bag, 2 muted yellow bags"
(def x "light red bags contain 1 bright white bag, 2 muted yellow bags")
(clojure.string/split x #" contains ")
(clojure.string/split x #" contain ")
(first (clojure.string/split x #" contain "))
(second (clojure.string/split x #" contain "))
(def bags "1 bright white bag, 2 muted yellow bags")
bags
(def bags (clojure.string/split "1 bright white bag, 2 muted yellow bags" #","))
bags
(def bags (clojure.string/split "1 bright white bag, 2 muted yellow bags" #", "))
bags
(map #((clojure.string/split % #"/d+ ")) bags)
bags
(first bags)
(clojure.string/split (first bags) #"/d+ ")
(clojure.string/split (first bags) #"/d")
(clojure.string/split (first bags) #"^/d")
(clojure.string/split (first bags) #"^\d")
(clojure.string/split (first bags) #"^\d+")
(clojure.string/split (first bags) #"^\d +")
(re-find (first bags) #"^\d +")
(re-find #"^\d +" (first bags))
(re-matches #"^\d +" (first bags))
(re-matches #"^\d+ " (first bags))
(re-matches #"^\d" (first bags))
(re-matches #"^\d " (first bags))
(re-find #"^\d+ *" (first bags))
(re-matches #"^\d+ *" (first bags))
(re-seq #"^\d+ " (first bags))
(bags
)
(first bags)
(re-seq #"[^\d+ ]" (first bags))
(re-seq #"[^\d+]" (first bags))
(re-seq #"[^\d]" (first bags))
(re-seq #"[^\d]+|=" (first bags))
(re-seq #"[^0-9]+|=" (first bags))
(re-seq #"[^0-9]+|[0-9]" (first bags))
(re-seq #"[^0-9 ]+|[0-9]" (first bags))
(re-seq #"[^0-9]+|[0-9]" (first bags))
(re-seq #"[^0-9 ]+|[0-9 ]" (first bags))
(re-seq #"[^0-9]+|[0-9]" (first bags))
(first bags)
(d7/parse-bag "1 bright white bag")
(:bright white bag (d7/parse-bag "1 bright white bag"))
(d7/parse-bag "1 bright white bag")
(:bright_white_bag (d7/parse-bag "1 bright white bag"))
d7/input
d7/input-test
(d7/parse d7/input-test)
(map #(d7/parse %) d7/input-test)
(d7/parse (first d7/input-test))
(def data (first d7/input-test))
data
(def split-vals (clojure.string/split data #" contain "))
split-vals
(:require '[clojure.string :as str])
(def bag-key (keyword (str/replace (first split-vals) #" " "_")))
(:import '[clojure.string :as str])
(def bag-key (keyword (str/replace (first split-vals) #" " "_")))
(require '[clojure.string :as str])
(def bag-key (keyword (str/replace (first split-vals) #" " "_")))
bag-key
(def bags (str/split (second split-vals) #","))
bags
(d7/parse (first d7/input-test))
d7/input-test
(into {} d7/input-test)
(first d7/input-test)
(find (first d7/input-test) :shiny_gold_bag)
(find (nth d7/input-test 0) :shiny_gold_bag)
(find (nth d7/input-test 1) :shiny_gold_bag)
(find (nth d7/input-test 2) :shiny_gold_bag)
(find (nth d7/input-test 3) :shiny_gold_bag)
(find (nth d7/input-test 4) :shiny_gold_bag)
(find (nth d7/input-test 5) :shiny_gold_bag)
(get-in (nth d7/input-test 2) :shiny_gold_bag)
(nth d7/input-test 2)
(flatten (nth d7/input-test 2))
(def foo '(:a b :c d))
foo
(into [] foo)
(nth d7/input-test 2)
(get-in (nth d7/input-test 2) :shiny_gold_bag)
(get-in (nth d7/input-test 2) [:shiny_gold_bag])
(find (nth d7/input-test 2) [:shiny_gold_bag])
(find (first (nth d7/input-test 2)) [:shiny_gold_bag])
(get-in (first (nth d7/input-test 2)) [:shiny_gold_bag])
(get (first (nth d7/input-test 2)) [:shiny_gold_bag])
(get (first (nth d7/input-test 2)) :shiny_gold_bag)
(first (nth d7/input-test 2))
(defn find-nested
  [m k]
  (->> (tree-seq map? vals m)
       (filter map?)
       (some k)))
(find-nested (nth d7/input-test 2) :shiny_gold_bag)
(tree-seq map? vals (nth d7/input-test 2))
(nth d7/input-test 2)
(map? [{:a b}])
(map? [{:a "a"}])
(vector? [{:a "a"}])
(into {} [{:a "a"}])
(into {} ({:a "a"}))
(into {} '({:a "a"}))
(nth d7/input-test 2)
(get-in (first (nth d7/input-test 2)) [:shiny_gold_bag])
(get-in (nth d7/input-test 2) [:shiny_gold_bag])
(find (nth d7/input-test 2) [:shiny_gold_bag])
(get-in (nth d7/input-test 2) [:shiny_gold_bag])
(defn find-nested
  [m k]
  (->> (tree-seq map? vals m)
       (filter map?)
       (some k)))
(find-nested (nth d7/input-test 2) :shiny_gold_bag)
(find-nested (nth d7/input-test 1) :shiny_gold_bag)
(tree-seq map? vals (nth d7/input-test 1))
(tree-seq map? vals (nth d7/input-test 2))
(tree-seq map? seq (nth d7/input-test 2))
(tree-seq map? children (nth d7/input-test 2))
(tree-seq map? identity (nth d7/input-test 2))
(def foo (tree-seq map? vals (nth d7/input-test 2)))
foo
(nth foo 0)
(nth foo 1)
(nth foo 2)
(nth foo 3)
(def foo (tree-seq map? keyword (nth d7/input-test 2)))
foo
(nth foo 0)
(nth foo 1)
(vals (nth d7/input-test 2))
(first (vals (nth d7/input-test 2)))
(vals (nth d7/input-test 2))
(def foo {:a "b" :b :"c"})
(def foo {:a "b" :b "c"})
foo
(vals foo)
(vals (nth d7/input-test 2))
(vals (nth d7/input-test 1))
(nth d7/input-test 1)
(keys (nth d7/input-test 1))
(vals (nth d7/input-test 2))
(first (vals (nth d7/input-test 2)))
(contains? (first (vals (nth d7/input-test 2))) :shiny_gold_bag)
(contains? (vals (nth d7/input-test 2)) :shiny_gold_bag)
(map #(contains? % :shiny_gold_bag) (vals (nth d7/input-test 2)))
(map #(contains? % :shiny_gold_bag) (vals (nth d7/input-test 1)))
(map #(contains? % :shiny_gold_bag) (vals (nth d7/input-test 0)))
(map #(contains? % :shiny_gold_bag) (vals (nth d7/input-test 3)))
(vals (nth d7/input-test 2))
(vals (nth d7/input-test 1))
(first (vals (nth d7/input-test 1)))
(contains? (first (vals (nth d7/input-test 1))) :muted_yellow_bags)
(contains? (vals (nth d7/input-test 1)) :muted_yellow_bags)
(contains? (flatten (vals (nth d7/input-test 1))) :muted_yellow_bags)
(flatten (vals (nth d7/input-test 1)))
(defn bag-has-bag? [m k]
  "Returns the bag key if the bag contains a given a bag"
  (let [mk (first (keys m))
        has-key (some true? (map #(contains? % k) (vals m)))]
        (if has-key mk nil)))
(map #(bag-has-bag % :shiny_gold_bag) d7/input-test)
(map #(bag-has-bag? % :shiny_gold_bag) d7/input-test)
(nth (d7/input-test) 3)
(nth (d7/input-test) 2)
(nth d7/input-test 2)
(nth d7/input-test 3)
(map #(bag-has-bag? % :shiny_gold_bag) d7/input-test)
(defn bag-has-bag? [m k]
  "Returns the bag key if the bag contains a given a bag"
  (let [mk (first (keys m))
        has-key (some true? (map #(contains? % k) (vals m)))]
        (if has-key mk nil)))
(map #(bag-has-bag? % :shiny_gold_bag) d7/input-test)
(map #(bag-has-bag? % :bright_white_bag) d7/input-test)
(map #(bag-has-bag? % :muted_yellow_bag) d7/input-test)
(map #(bag-has-bag? % :dark_orange_bag) d7/input-test)
(map #(bag-has-bag? % :muted_yellow_bag) d7/input-test)
(into [] (map #(bag-has-bag? % :muted_yellow_bag) d7/input-test))
(def foo (into [] (map #(bag-has-bag? % :muted_yellow_bag) d7/input-test))
)
foo
(remove nil? foo)
(empty? [])
(assoc [:a :b] :c)
(assoc :c [:a :b])
(conj [:a :b] :c)
(conj [:a :b] nil)
(conj [:a :b] [])
(conj [:a :b] [:c])
(flatten (conj [:a :b] [:c]))
(flatten (conj [:a :b] []))
(defn find-bags
  ([m ks]
    (let [found-bags (into [] (remove nil? (map #(bag-has-bag? m ks))))]
      (if (empty? found-bags) [] (find-bags m found-bags []))))
  ([m ks checked]
    (let [next-bag (first ks)
          checked-bags (conj checked next-bag)
          found-bags (into [] (remove nil? (map #(bag-has-bag? m next-bag)))
          remaining (flatten (conj ks found-bags))]
      (if (empty? remaining) checked-bags (find-bags m checked-bags remaining))))))
(d7/find-bags d7/input-test :abc)
(d7/find-bags d7/input-test :shiny_gold_bag)
(map #(d7/bag-has-bag? d7/input-test :shiny_gold_bag)
(d7/find-bags d7/input-test :shiny_gold_bag)
(hash-map :a :b :c)
(next '[a b c])
(next '[])
(conj (next []) "c")
(conj (into [] (next [])) "c")
(conj (into [] (next ["a" "b"])) "c")
(conj (into [] (next ["a" "b" "d"])) "c")
(next [])
(next [a])
(next ["a"])
(d7/find-bags d7/input-test :shiny_gold_bag)
(conj ["a" "b"] nil)
(into [] ())
(into [] [])
(conj [] [])
(d7/find-bags d7/input-test :shiny_gold_bag)
(map #(d7/bag-has-bag? % nil) d7/input-test)
(d7/find-bags d7/input-test :shiny_gold_bag)
(def c1 (d7/find-bags d7/input-test :shiny_gold_bag))
(first c1)
(second c1)
(flatten ["a" "b" ["c"]])
(def c1 (d7/find-bags d7/input-test :shiny_gold_bag))
(first c1)
(second c1)
(def c2 (d7/find-bags d7/input-test (first c1) (second c1)))
c2
c1
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
c1
(def c2 (d7/find-bags d7/input-test (first c1) (second c1)))
c2
c1
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
c1
(def c2 (d7/find-bags d7/input-test (first c1) (second c1)))
c2
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
c1
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test (first c1) (second c1)))
c1
(def c1 (d7/find-bags d7/input-test [:shiny_gold_bag] []))
c1
(def c1 (d7/find-bags d7/input-test :shiny_gold_bag))
c1
(def c1 (d7/find-bags d7/input-test :shiny_gold_bag))
c1
(def c1 (d7/find-bags d7/input :shiny_gold_bag))
c1
(count c1)
d7-solution-part1
