d1-solution-part1
d1-solution-part2
d2-solution-part2
d3-solution-part2
d2-solution-part2
d2-solution-part1
(d3/index-map d3/it)
(d3/it)
d3/it
(nth 0 d3/it)
(nth d3/it 0)
(d3/line-char (nth d3/it 0))
(d3/line->char (nth d3/it 0))
(map #(d3/line->char %1) d3/it)  
(map #(hash-map :v %1 :x %2) (d3/line->char (nth d3/it 0)))
(map #(hash-map :v %1 :x %2) (d3/line->char (nth d3/it 0)) (interate inc 1))
(map #(hash-map :v %1 :x %2) (d3/line->char (nth d3/it 0)) (inc 1))
(map #(hash-map :v %1 :x %2) (d3/line->char (nth d3/it 0)) (iterate inc 1))
x
d3/x
(take 10 (iterate inc 0))
(map #(x-axis %1 %2) it (iterate inc 0))
(map #(d3/x-axis %1 %2) d3/it (iterate inc 0))
(d3/y-axis)
d3/y-axis
d3/input
d3/y-axis
(flatten d3/y-axis)
(into {} d3/y-axis)
(into {} (flatten d3/y-axis))
d3/y-axis
(flatten d3/y-axis)
(into (sorted-map) d3/y-axis)
(into (sorted-map) (flatte d3/y-axis))
(into (sorted-map) (flatten d3/y-axis))
(zipmap [:el] (flatten d3/y-axis))
(zipmap [:el] (d3/y-axis))
(zipmap [:el] d3/y-axis)
(map #(zipmap %2 (d3/x-axis %1)) d3/it (iterate inc 0))
(map #(zipmap %2 (d3/x-axis %1 0)) d3/it (iterate inc 0))
(map #(zipmap %2 (d3/x-axis %1 %2)) d3/it (iterate inc 0))
(flatten d3/y-axis)
(d3/index-map d3/input-test)
(apply max-key #(val (:y %)) (d3/index-map d3/input-test)
)
(apply max-key val (d3/index-map d3/input-test))
(assoc {} (d3/index-map d3/input-test))
(def test {:00 {:y 0 :x 0 :val "."}})
(def tst {:00 {:y 0 :x 0 :val "."}})
txt
tst
(string
 1 2)
(clojure.string/join 1 2)
(map #(hash-map (str %1 %2) "foo") (0 0 0) (1 2 3)) 
(map #(hash-map (str %1 %2) "foo") '(0 0 0) '(1 2 3)) 
(count d3/it)
(count d3/input)
(d3/index-map d3/input)
(filter #(= (:y %) :1) (d3/index-map d3/input)))
(filter #(= (:y %) 1) (d3/index-map d3/input))
(filter #((AND (= (:x %) 1) (= (:y %) 1))) (d3/index-map d3/input))
(filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input))
(:v (filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)))
(get (filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)) :v)
(get (filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)) 0)
(filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input))
(take 1 (filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)))
((filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)) :v)
(nth (filter #(and (= (:x %) 1) (= (:y %) 1)) (d3/index-map d3/input)) 0)
(re-find #["#"] "#")
(re-find #["\\#"] "\\#")
(re-find #["\#"] "\#")
(re-find #["\#"] "#")
(re-find #["\\#"] "#")
(re-find #["\\#"] "\#")
(re-find #["a"] "a")
(boolean (re-find #["a"] "a"))
(boolean (re-find #["a"] '"a"))
(re-matches #["a"] "a")
(re-matches #"a" "a")
(re-find #"a" "a")
(boolean (re-find #"a" "a"))
(boolean (re-find #"a" "b"))
(boolean (re-find #"a" "#"))
(boolean (re-find #"#" "#"))
(d3/tree? 2 5 d3/input)
(map #(hash-map :check %1) (take 5 (iterate inc 0)))
(map #(hash-map :check %1 :y %1 :x) (take 5 (iterate inc 0)) (iterate (partial + 3) 0))
(map #(hash-map :check %1 :y %1 :x %2) (take 5 (iterate inc 0)) (iterate (partial + 3) 0))
(defn create-checks [data]
  (let [width (count (line-> char (nth data 0)))
        height (count data)]
        (map #(hash-map :check %1 :y %1 :x %2) (take height (iterate inc 0)) (iterate (partial + 3) 0))))
(defn create-checks [data]
  (let [width (count (line->char (nth data 0)))
        height (count data)]
        (map #(hash-map :check %1 :y %1 :x %2) (take height (iterate inc 0)) (iterate (partial + 3) 0))))
(defn create-checks [data]
  (let [width (count (d3/line->char (nth data 0)))
        height (count data)]
        (map #(hash-map :check %1 :y %1 :x %2) (take height (iterate inc 0)) (iterate (partial + 3) 0))))
(create-checks d3/input-test)
(count (d3/line->char (nth d3/input-test 0)))
(create-checks d3/it)
(defn create-checks [data]
  (let [width (count (d3/line->char (nth data 0)))
        height (count data)]
        (map #(hash-map :check %1 :y %1 :x %2) (take height (iterate inc 0)) (iterate (partial + 3) 0))))
(create-checks d3/it)
(/ 24 11)
(/ 11 24)
(int (Math/floor 24 11))
(int (Math/floor (/ 24 11))
)
(int (Math/floor (/ 36 11)))
(int (Math/floor (/ 37 11)))
(* 3 11)
(- 37 33)
(create-checks d3/input-test)
(defn calcx [length x]
  (let [repeated (int (Math/floor (/ x length)))])
  (- x (* repeated length)))
(defn calcx [length x]
  (let [repeated (int (Math/floor (/ x length)))]
  (- x (* repeated length))))
(calcx 11 30)
(def bla {:check "A"})
(bla :check)
(map #(hash-map :check (%1 :check) :tree ((%1 :x) (%1 :y) d3/input-test) ) (d3/create-checks d3/input-test))
(d3/create-checks d3/input-test)
(defn create-checks [data]
  (let [width (count (d3/line->char (nth data 0)))
        height (count data)]
        (map #(hash-map :check %1 :y %1 :x (calcx width %2)) (take height (iterate inc 0)) (iterate (partial + 3) 0))))
(create-checks d3/input-test)
(d3/tree? 1 2 d3/input-test)
(map #(hash-map :check (%1 :check) :tree (d3/tree? (%1 :x) (%1 :y) d3/input-test) ) (create-checks d3/input-test))
(def foo `({:check 1 :x 1} {:check 2 :x2}))
(def foo ({:check 1 :x 1} {:check 2 :x2}))
(def foo ({:check 1 :x 1} {:check 2 :x 2}))
foo
(def foo '({:check 1 :x 1} {:check 2 :x 2}))
foo
(def bar '({:check 1 :y 1} {:check 2 :y 2}))
bar
(d3/part1 d3/input-test)
(filter #(%1 :tree) (d3/part1 d3/input-test))
(count (filter #(%1 :tree) (d3/part1 d3/input-test)))
(d3/p1-solution d3/input-test)
(d3/p1-solution d3/input)
(def path [:x 1 :y 3])
(path :x)
(:x path)
(def path {:x 1 :y 1})
path
(path :x)
(d3/p1-solution d3/input)
(def path {:x 1 :y 1})
(iterate (partial + (path :x)) 0)
(d3/p1-solution d3/input)
(d3/p2-solution d3/input)
(d3/p1-solution d3/input)
(d3/p2-solution d3/input)
(def data d3/input)
(def width (count (line->char (nth data 0))))
(def width (count (d3/line->char (nth data 0))))
width
(def height (count data))
height
(defn offset-x [length x]
  (let [repeated (int (Math/floor (/ x length)))]
  (- x (* repeated length))))
checks (map #(hash-map :check %1 :y %2 :x (offset-x width %3)) (take height (iterate inc 0)) (iterate (partial + (path :y)) 0) (iterate (partial + (path :x)) 0))]
(def checks (map #(hash-map :check %1 :y %2 :x (offset-x width %3)) (take height (iterate inc 0)) (iterate (partial + (path :y)) 0) (iterate (partial + (path :x)) 0))]
(def checks (map #(hash-map :check %1 :y %2 :x (d3/offset-x width %3)) (take height (iterate inc 0)) (iterate (partial + (path :y)) 0) (iterate (partial + (path :x)) 0))
)
(def path {:x 1 :y 2})
(def checks (map #(hash-map :check %1 :y %2 :x (offset-x width %3)) 
          (take height (iterate inc 0)) 
          (iterate (partial + (path :y)) 0) 
))))
(def checks checks (map #(hash-map :check %1 :y %2 :x (offset-x width %3)) 
          (take height (iterate inc 0)) 
          (iterate (partial + (path :y)) 0) 
          (iterate (partial + (path :x)) 0))
)
(defn offset-x [length x]
  (let [repeated (int (Math/floor (/ x length)))]
  (- x (* repeated length))))
(def checks (map #(hash-map :check %1 :y %2 :x (offset-x width %3)) 
          (take height (iterate inc 0)) 
          (iterate (partial + (path :y)) 0) 
          (iterate (partial + (path :x)) 0)))
checks
(def checks (map #(hash-map :check %1 :y %2 :x (d3/offset-x width %3)) 
          (take (/ height (path :y) (iterate (partial + (path :y)) 0)) 
          (iterate inc 0) 
          (iterate (partial + (path :x)) 0)))
)
(def checks (map #(hash-map :check %1 :y %2 :x (d3/offset-x width %3)) 
          (take (/ height (path :y)) (iterate (partial + (path :y)) 0)) 
          (iterate inc 0) 
          (iterate (partial + (path :x)) 0)))
checks
height
(def checks (map #(hash-map :check %1 :y %2 :x (d3/offset-x width %3)) 
          (take (/ height (path :y)) (iterate (partial + (path :y)) 0)) 
          (iterate (partial + (path :y)) 0)
          (iterate (partial + (path :x)) 0)))
checks
(d3/p1-solution d3/input)
(d3/p2-solution d3/input)
(def p2res (d3/p2-solution d3/input))
p2res
(nth p2res 0)
(map #(count (filter #(% :tree))) p2res)
 (map (fn [x] (filter x :tree)) p2res)
 (map #(filter (fn [x] (x :tree)) %) p2res)
 (map #(count (filter (fn [x] (x :tree)) %)) p2res)
(def foo (map #(count (filter (fn [x] (x :tree)) %)) p2res))
foo
(map #(reduce * %) foo)
(reduce * foo)
(d3/p2-solution d3/input-test)
(def walks [{:x 1 :y 1} {:x 3 :y 1} {:x 5 :y 1} {:x 7 :y 1} {:x 1 :y 2}])
walks
(def walk-result (map #(walk-forest data %) walks))
(def walk-result (map #(d3/walk-forest d3/input-test %) walks))
(d3/p2-solution d3/input-test)
(d3/p2-solution d3/input)
(map #(trees-encountered d3/test-input %) d3/p1-paths)
(map #(d3/trees-encountered d3/test-input %) d3/p1-paths)
(map #(d3/trees-encountered d3/input-test %) d3/p1-paths)
(map #(d3/trees-encountered d3/input-test %) d3/p2-paths)
(reduce * (map #(d3/trees-encountered d3/input-test %) d3/p2-paths))
(reduce * (map #(d3/trees-encountered d3/input-test %) d3/p1-paths))
(d3-solution-part1)
d3-solution-part1
d3-solution-part2
